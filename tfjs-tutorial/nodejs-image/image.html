<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>    
    // fetch('https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8').then(res => {
    //   const t = res.arrayBuffer();
    //   t.then(data => {
    //     console.log(data.slice(0, 10))

    //   })
    // })

    const IMAGE_H = 28;
    const IMAGE_W = 28;
    const IMAGE_SIZE = IMAGE_H * IMAGE_W;
    const NUM_CLASSES = 10;
    const NUM_DATASET_ELEMENTS = 1;

    const NUM_TRAIN_ELEMENTS = 55000;
    const NUM_TEST_ELEMENTS = NUM_DATASET_ELEMENTS - NUM_TRAIN_ELEMENTS;

    const MNIST_IMAGES_SPRITE_PATH = 'mnist_images.png';


    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const imgRequest = new Promise((resolve, reject) => {
      img.crossOrigin = '';
      img.onload = () => {
        img.width = img.naturalWidth;
        img.height = img.naturalHeight;

        const datasetBytesBuffer =
            new ArrayBuffer(NUM_DATASET_ELEMENTS * IMAGE_SIZE * 4);

        const chunkSize = 1;
        canvas.width = img.width;
        canvas.height = chunkSize;

        for (let i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++) {
          const datasetBytesView = new Float32Array(
              datasetBytesBuffer, i * IMAGE_SIZE * chunkSize * 4,
              IMAGE_SIZE * chunkSize);
          ctx.drawImage(
              img, 0, i * chunkSize, img.width, chunkSize, 0, 0, img.width,
              chunkSize);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

          for (let j = 0; j < imageData.data.length / 4; j++) {
            // All channels hold an equal value since the image is grayscale, so
            // just read the red channel.
            datasetBytesView[j] = imageData.data[j * 4];
          }
        }
        let datasetImages = new Float32Array(datasetBytesBuffer);
        console.log(to2DImageData(datasetImages))
        resolve();
      };
      img.src = MNIST_IMAGES_SPRITE_PATH;
    });

    function to2DImageData(image_data_1d) {
      if (image_data_1d.length !== IMAGE_SIZE) {
        throw new Error('image data length doesn\'t match');    
      }

      const imageRows = new Array(IMAGE_H).fill(0);
      return imageRows.map((_, rowIndex) => image_data_1d.slice(rowIndex * IMAGE_W, (rowIndex + 1) * IMAGE_W));  
    }
  </script>
</body>
</html>